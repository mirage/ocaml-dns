<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pure (dns-client.Dns_client.Pure)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">dns-client</a> &#x00BB; <a href="../index.html">Dns_client</a> &#x00BB; Pure</nav><h1>Module <code>Dns_client.Pure</code></h1></header><aside><p>The pure interface to the client part of uDns.</p><p>Various helper modules to do with side effects are available from <a href="../../Dns_client_lwt/index.html"><code>Dns_client_lwt</code></a>, <a href="../../Dns_client_unix/index.html"><code>Dns_client_unix</code></a> and so forth.</p></aside><dl><dt class="spec type" id="type-query_state"><a href="#type-query_state" class="anchor"></a><code><span class="keyword">type</span> <span>'key query_state</span></code><code> <span class="keyword">constraint</span> <span class="type-var">'key</span> = <span><span class="type-var">'a</span> Dns.Rr_map.key</span></code></dt><dd><p><code>query_state</code> is parameterized over the query type, so the type of the representation of the answer depends on what the name server was asked to provide. See <span class="xref-unresolved" title="unresolved reference to &quot;Dns_map.k&quot;"><code>Dns_map</code>.k</span> for a list of response types. The first element (the <code>int32</code>) in most of the tuples is the Time-To-Live (TTL) field returned from the server, which you can use to calculate when you should request fresh information in case you are writing a long-running application.</p></dd></dl><dl><dt class="spec value" id="val-make_query"><a href="#val-make_query" class="anchor"></a><code><span class="keyword">val</span> make_query : <span>(int <span>&#45;&gt;</span> Cstruct.t)</span> <span>&#45;&gt;</span> <a href="../../../dns/Dns/index.html#type-proto">Dns.proto</a> <span>&#45;&gt;</span> <span><span class="type-var">'a</span> Domain_name.t</span> <span>&#45;&gt;</span> <span><span class="type-var">'query_type</span> <a href="../../../dns/Dns/index.html#module-Rr_map">Dns.Rr_map</a>.key</span> <span>&#45;&gt;</span> Cstruct.t * <span><span><span class="type-var">'query_type</span> <a href="../../../dns/Dns/index.html#module-Rr_map">Dns.Rr_map</a>.key</span> <a href="index.html#type-query_state">query_state</a></span></code></dt><dd><p><code>make_query rng protocol name query_type</code> is <code>query, query_state</code> where <code>query</code> is the serialized DNS query to send to the name server, and <code>query_state</code> is the information required to validate the response.</p></dd></dl><dl><dt class="spec value" id="val-parse_response"><a href="#val-parse_response" class="anchor"></a><code><span class="keyword">val</span> parse_response : <span><span><span class="type-var">'query_type</span> <a href="../../../dns/Dns/index.html#module-Rr_map">Dns.Rr_map</a>.key</span> <a href="index.html#type-query_state">query_state</a></span> <span>&#45;&gt;</span> Cstruct.t <span>&#45;&gt;</span> <span><span>(<span>[ <span>`Data of <span class="type-var">'query_type</span></span> <span>| `Partial</span> <span><span>| `No_data</span> of <span><span>[ `raw ]</span> Domain_name.t</span> * <a href="../../../dns/Dns/Soa/index.html#type-t">Dns.Soa.t</a></span> <span><span>| `No_domain</span> of <span><span>[ `raw ]</span> Domain_name.t</span> * <a href="../../../dns/Dns/Soa/index.html#type-t">Dns.Soa.t</a></span> ]</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> Stdlib.result</span></code></dt><dd><p><code>parse_response query_state response</code> is the information contained in <code>response</code> parsed using <code>query_state</code> when the query was successful, or an <code>`Msg message</code> if the <code>response</code> did not match the <code>query_state</code> (or if the query failed).</p><p>In a TCP usage context the <code>`Partial</code> means there are more bytes to be read in order to parse correctly. This can happen due to short reads or if the server (or something along the route) chunks its responses into multiple individual packets. In that case you should concatenate `response` and the next received data and call this function again. In a UDP usage context the <code>`Partial</code> means information was lost, due to an incomplete packet.</p></dd></dl></div></body></html>