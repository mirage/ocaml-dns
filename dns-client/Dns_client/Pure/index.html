<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Pure (dns-client.Dns_client.Pure)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – <a href="../../index.html">dns-client</a> &#x00BB; <a href="../index.html">Dns_client</a> &#x00BB; Pure</nav><header class="odoc-preamble"><h1>Module <code><span>Dns_client.Pure</span></code></h1><p>The pure interface to the client part of uDns.</p><p>Various helper modules to do with side effects are available from <a href="../../Dns_client_lwt/index.html"><code>Dns_client_lwt</code></a>, <a href="../../Dns_client_unix/index.html"><code>Dns_client_unix</code></a> and so forth.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-query_state" class="anchored"><a href="#type-query_state" class="anchor"></a><code><span><span class="keyword">type</span> <span>'key query_state</span></span><span> <span class="keyword">constraint</span> <span class="type-var">'key</span> = <span><span class="type-var">'a</span> <a href="../../../dns/Dns/Rr_map/index.html#type-key">Dns.Rr_map.key</a></span></span></code></div><div class="spec-doc"><p><code>query_state</code> is parameterized over the query type, so the type of the representation of the answer depends on what the name server was asked to provide. See <code>Dns_map</code>.k for a list of response types. The first element (the <code>int32</code>) in most of the tuples is the Time-To-Live (TTL) field returned from the server, which you can use to calculate when you should request fresh information in case you are writing a long-running application.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make_query" class="anchored"><a href="#val-make_query" class="anchor"></a><code><span><span class="keyword">val</span> make_query : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Cstruct</span>.t)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../../../dns/Dns/index.html#type-proto">Dns.proto</a> <span class="arrow">&#45;&gt;</span></span> <span><span>[ `None <span>| `Auto</span> <span><span>| `Manual</span> of <a href="../../../dns/Dns/Edns/index.html#type-t">Dns.Edns.t</a></span> ]</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <span class="xref-unresolved">Domain_name</span>.t</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'query_type</span> <a href="../../../dns/Dns/Rr_map/index.html#type-key">Dns.Rr_map.key</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Cstruct</span>.t * <span><span><span class="type-var">'query_type</span> <a href="../../../dns/Dns/Rr_map/index.html#type-key">Dns.Rr_map.key</a></span> <a href="#type-query_state">query_state</a></span></span></code></div><div class="spec-doc"><p><code>make_query rng protocol name query_type</code> is <code>query, query_state</code> where <code>query</code> is the serialized DNS query to send to the name server, and <code>query_state</code> is the information required to validate the response.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-parse_response" class="anchored"><a href="#val-parse_response" class="anchor"></a><code><span><span class="keyword">val</span> parse_response : <span><span><span><span class="type-var">'query_type</span> <a href="../../../dns/Dns/Rr_map/index.html#type-key">Dns.Rr_map.key</a></span> <a href="#type-query_state">query_state</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Cstruct</span>.t <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>[ <span>`Data of <span class="type-var">'query_type</span></span> <span>| `Partial</span> <span><span>| `No_data</span> of <span><span>[ `raw ]</span> <span class="xref-unresolved">Domain_name</span>.t</span> * <a href="../../../dns/Dns/Soa/index.html#type-t">Dns.Soa.t</a></span> <span><span>| `No_domain</span> of <span><span>[ `raw ]</span> <span class="xref-unresolved">Domain_name</span>.t</span> * <a href="../../../dns/Dns/Soa/index.html#type-t">Dns.Soa.t</a></span> ]</span>, <span>[ <span>`Msg of string</span> ]</span>)</span> <span class="xref-unresolved">Stdlib</span>.result</span></span></code></div><div class="spec-doc"><p><code>parse_response query_state response</code> is the information contained in <code>response</code> parsed using <code>query_state</code> when the query was successful, or an <code>`Msg message</code> if the <code>response</code> did not match the <code>query_state</code> (or if the query failed).</p><p>In a TCP usage context the <code>`Partial</code> means there are more bytes to be read in order to parse correctly. This can happen due to short reads or if the server (or something along the route) chunks its responses into multiple individual packets. In that case you should concatenate <code>response</code> and the next received data and call this function again.</p><p>In a UDP usage context the <code>`Partial</code> means information was lost, due to an incomplete packet.</p></div></div></div></body></html>